/* --------------------------------------------------------------------------------
 #
 #  4DPlugin-iCal.cpp
 #	source generated by 4D Plugin Wizard
 #	Project : iCal
 #	author : miyako
 #	2020/03/17
 #
 # --------------------------------------------------------------------------------*/

#include "4DPlugin-iCal.h"

#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wdeprecated-declarations"

EKEventStore *defaultCalendarStore = nil;

EKEventStore *_getDefaultCalendarStore() {
    
    if(!defaultCalendarStore) {
        defaultCalendarStore = [[EKEventStore alloc]init];
        if(defaultCalendarStore) {
            NSArray<EKSource *> *delegateSources = [defaultCalendarStore delegateSources];
            if(delegateSources) {
                delegateSources = [delegateSources arrayByAddingObjectsFromArray:[defaultCalendarStore sources]];
                EKEventStore *_defaultCalendarStore = [[EKEventStore alloc]initWithSources:delegateSources];
                if(_defaultCalendarStore) {
                    [defaultCalendarStore release];
                    defaultCalendarStore = _defaultCalendarStore;
                }
            }
        }
    }
    
    return defaultCalendarStore;
}

#pragma mark Notification

#define MAX_PROCESS_NAME 256

static bool IsProcessOnExit()
{
    std::vector<PA_Unichar> name(MAX_PROCESS_NAME);
    
    PA_long32 state, time;
    
    PA_GetProcessInfo(PA_GetCurrentProcessNumber(), (PA_Unichar *)&name[0], &state, &time);
    
    CUTF16String procName((PA_Unichar *)&name[0]);
    CUTF16String exitProcName((PA_Unichar *)"$\0x\0x\0\0\0");
    return (!procName.compare(exitProcName));
}

#define CALLBACK_IN_NEW_PROCESS 0
#define CALLBACK_SLEEP_TIME 59

namespace iCalv4
{
//constants
process_name_t MONITOR_PROCESS_NAME = (PA_Unichar *)"$\0C\0A\0L\0E\0N\0D\0A\0R\0\0\0";
process_stack_size_t MONITOR_PROCESS_STACK_SIZE = 0;

CUTF16String LISTENER_METHOD;

//context management
std::vector<CUTF8String> notifications;

//callback management
process_number_t METHOD_PROCESS_ID = 0;
bool PROCESS_SHOULD_TERMINATE = false;
bool PROCESS_SHOULD_RESUME = false;
}

std::mutex globalMutex; /* for INSERT_RECORDS,UPDATE_RECORDS,DELETE_RECORDS */
std::mutex globalMutex1;/* for METHOD_PROCESS_ID */
std::mutex globalMutex2;/* for LISTENER_METHOD */
std::mutex globalMutex3;/* PROCESS_SHOULD_TERMINATE */
std::mutex globalMutex4;/* PROCESS_SHOULD_RESUME */

@interface iCalv4Responder : NSObject
- (void)storeChanged:(NSNotification *)notification;
@end

@implementation iCalv4Responder
- (id)init
{
    if(!(self = [super init])) return self;
    
    [[NSNotificationCenter defaultCenter]
     addObserver:self
     selector:@selector(storeChanged:)
     name:EKEventStoreChangedNotification
     object:nil];
    
    [defaultCalendarStore calendarsForEntityType:EKEntityTypeEvent];
    //EKEventStoreChangedObjectIDsUserInfoKey is missing if we don't do this first
    
    return self;
}
- (void)storeChanged:(NSNotification *)notification
{
    NSDictionary *userInfo = [notification userInfo];
    bool isCalendarEvent = [[userInfo objectForKey:@"EKEventStoreCalendarDataChangedUserInfoKey"]boolValue];
    
    if(isCalendarEvent) {
        
        if(1)
        {
            std::lock_guard<std::mutex> lock(globalMutex);
            
            /*
             @autoreleasepool {
             for(NSManagedObjectID *objectID in [userInfo objectForKey:@"EKEventStoreChangedObjectIDsUserInfoKey"]) {
             NSString *description = [[objectID URIRepresentation]absoluteString];
             if([description containsString:@"/Event/"]){
             NSString *uid = eventForObject(description);
             CUTF8String notificationString = CUTF8String((const uint8_t *)[[NSString stringWithFormat:@"%@\t%@", description, uid ? uid : @""] UTF8String]);
             iCalv4::notifications.push_back(notificationString);
             }
             }
             }
             */
            CUTF8String notificationString = CUTF8String((const uint8_t *)"");
            iCalv4::notifications.push_back(notificationString);
        }
        listenerLoopExecute();
    }
}
- (void)dealloc
{
    [[NSNotificationCenter defaultCenter]
     removeObserver:self
     name:EKEventStoreChangedNotification
     object:nil];
    
    [super dealloc];
}
@end

static iCalv4Responder *responder = nil;

static void listener_start(EKEventStore *eventStore)
{
    responder = [[iCalv4Responder alloc]init];
}

static void listener_end()
{
    [responder release];
}

static void OnStartup()
{
    listenerLoopStart();
}

static void OnCloseProcess()
{
    if(IsProcessOnExit())
    {
        listenerLoopFinish();
        
        if(defaultCalendarStore) {
            [defaultCalendarStore release];
            defaultCalendarStore = nil;
        }
    }
}

#pragma mark Permission

std::mutex mutex_permission;

request_permission_t granted_permission = request_permission_unknown;

BOOL check_permission(PA_ObjectRef status) {
    
    BOOL returnValue = false;
    
    if(status) {
        
        switch (granted_permission) {
                
            case request_permission_authorized:
                returnValue = true;
                ob_set_b(status, L"success", returnValue);
                break;
                
            case request_permission_denied:
                returnValue = false;
                ob_set_b(status, L"success", returnValue);
                ob_set_s(status, L"errorMessage", "permission denied");
                return false;
                break;
                
            case request_permission_restricted:
                returnValue = false;
                ob_set_b(status, L"success", returnValue);
                ob_set_s(status, L"errorMessage", "permission restricted");
                break;
                
            case request_permission_not_determined:
                returnValue = false;
                ob_set_b(status, L"success", returnValue);
                ob_set_s(status, L"errorMessage", "permission not determined");
                break;
                
            default:
                break;
        }
    }
    
    return returnValue;
}

request_permission_t requestPermission(void) {
    
    std::lock_guard<std::mutex> lock(mutex_permission);
    
    if (@available(macOS 10.9, *)) {
        
        switch ([EKEventStore authorizationStatusForEntityType:EKEntityTypeEvent])
        {
            case EKAuthorizationStatusNotDetermined:
            {
                EKEventStore *store = [EKEventStore new];
                [store requestAccessToEntityType:EKEntityTypeEvent completion:^(BOOL granted, NSError * _Nullable error) {
                    if (granted) {
                        granted_permission = request_permission_authorized;
                    }
                }];
                granted_permission = request_permission_not_determined;
                break;
            }
                break;
                
            case EKAuthorizationStatusRestricted:
                granted_permission = request_permission_restricted;
                break;
                
            case EKAuthorizationStatusDenied:
                granted_permission = request_permission_denied;
                break;
                
            case EKAuthorizationStatusAuthorized:
                granted_permission = request_permission_authorized;
                break;
        }
        
    }
    
    if(granted_permission == request_permission_authorized) {
        defaultCalendarStore = _getDefaultCalendarStore();
        if(defaultCalendarStore) {
            listener_start(defaultCalendarStore);
        }
    }
    
    return granted_permission;
}

void iCal_Request_permisson(PA_PluginParameters params) {
    
    PA_ObjectRef status = PA_CreateObject();
    
    NSBundle *mainBundle = [NSBundle mainBundle];
    if(mainBundle) {
        NSDictionary *infoDictionary = [mainBundle infoDictionary];
        if(infoDictionary) {
            NSString *calendarUsageDescription = [infoDictionary objectForKey:@"NSCalendarsUsageDescription"];
            if(calendarUsageDescription) {
                
                SecTaskRef sec = SecTaskCreateFromSelf(kCFAllocatorMalloc);
                CFErrorRef err = nil;
                CFBooleanRef boolValue = (CFBooleanRef)SecTaskCopyValueForEntitlement(sec,
                                                                                      CFSTR("com.apple.security.personal-information.calendars"),
                                                                                      &err);
                if((!err) && (boolValue)){
                    if(boolValue) {
                        if(CFBooleanGetValue(boolValue)) {
                            
                            PA_RunInMainProcess((PA_RunInMainProcessProcPtr)requestPermission, NULL);
                            
                            check_permission(status);
                            
                        }else{
                            ob_set_b(status, L"success", false);
                            ob_set_s(status, L"errorMessage", "com.apple.security.personal-information.calendars is set to false in app entitlement");
                        }
                        CFRelease(boolValue);
                    }
                }else{
                    ob_set_b(status, L"success", false);
                    ob_set_s(status, L"errorMessage", "com.apple.security.personal-information.calendars is missing in app entitlement");
                }
                CFRelease(sec);
            }else{
                ob_set_b(status, L"success", false);
                ob_set_s(status, L"errorMessage", "NScalendarUsageDescription is missing in app info.plist");
            }
        }else{
            ob_set_b(status, L"success", false);
            ob_set_s(status, L"errorMessage", "failed to locate [mainBundle infoDictionary]");
        }
    }else{
        ob_set_b(status, L"success", false);
        ob_set_s(status, L"errorMessage", "failed to locate [NSBundle mainBundle]");
    }
    
    PA_ReturnObject(params, status);
}

#pragma mark -

void PluginMain(PA_long32 selector, PA_PluginParameters params) {
    
    try
    {
        switch(selector)
        {
                // --- iCal
                
            case 1 :
                iCal_Request_permisson(params);
                break;
            case 2 :
                iCal_QUERY_EVENT(params);
                break;
            case 3 :
                iCal_GET_CALENDAR_LIST(params);
                break;
                
            case 4 :
                iCal_Create_calendar(params);
                break;
            case 5 :
                iCal_Set_calendar_property(params);
                break;
            case 6 :
                iCal_Get_calendar_property(params);
                break;
            case 7 :
                iCal_Remove_calendar(params);
                break;
                
            case 8 :
                iCal_Create_event(params);
                break;
            case 9 :
                iCal_Set_event_property(params);
                break;
            case 10 :
                iCal_Get_event_property(params);
                break;
            case 11 :
                iCal_Remove_event(params);
                break;
                
            case 12 :
                iCal_Get_default_calendar(params);
                break;
                
                // added in v4
                
            case kInitPlugin :
            case kServerInitPlugin :
                OnStartup();
                break;
                
            case kCloseProcess :
                OnCloseProcess();
                break;
                
            case 13 :
                iCal_Set_notification_method(params);
                break;
            case 14 :
                iCal_Get_notification_method(params);
                break;
        }
        
    }
    catch(...)
    {
        
    }
}

#pragma mark -

NSColor *getRGBcolor(unsigned int rgb) {
    
    NSColor *color = NULL;
    
    CGFloat red, green, blue;
    
    red     = (CGFloat)(((rgb & 0x00FF0000) >> 16  ) / 0xFF);
    green   = (CGFloat)(((rgb & 0x0000FF00) >> 8   ) / 0xFF);
    blue    = (CGFloat)(((rgb & 0x000000FF)        ) / 0xFF);
    
    color = [NSColor colorWithDeviceRed:red
                                  green:green
                                   blue:blue
                                  alpha:1.0f];
    
    return color;
}

unsigned int getColorRGB(NSColor *color) {
    
    unsigned int rgb = 0;
    
    if(color)
    {
        color = [color colorUsingColorSpace:[NSColorSpace displayP3ColorSpace]];
        
        /*
         color = [color colorUsingColorSpace:[NSColorSpace deviceRGBColorSpace]];//NSDeviceRGBColorSpace
         color = [color colorUsingColorSpace:[NSColorSpace sRGBColorSpace]];
         color = [color colorUsingColorSpace:[NSColorSpace genericRGBColorSpace]];//NSCalibratedRGBColorSpace
         */
        
        CGFloat red, green, blue, alpha;
        [color getRed:&red green:&green blue:&blue alpha:&alpha];
        
        rgb +=
        
        /*
         +((unsigned int)(red      * 255.99999f) << 16)
         +((unsigned int)(green    * 255.99999f) << 8)
         + (unsigned int)(blue     * 255.99999f);
         */
        
        +((unsigned int)floor((CGFloat)(red      * 0xFF) + 0.5f) << 16)
        +((unsigned int)floor((CGFloat)(green    * 0xFF) + 0.5f) << 8)
        + (unsigned int)floor((CGFloat)(blue     * 0xFF) + 0.5f);
    }
    
    return rgb;
}

#pragma mark Calendar / PA_ObjectRef

void ob_set_calendar(PA_ObjectRef status,
                     EKCalendar *calendar
                     ) {
    
    if(status) {
        
        ob_set_v(status, L"title", calendar.title);
        
        ob_set_v(status, L"uid", calendar.calendarIdentifier);
        ob_set_n(status, L"color", calendar.color ? getColorRGB(calendar.color) : 0L);
        /* notes not supported in EK */
        
        switch (calendar.type) {
            case EKCalendarTypeLocal:
                ob_set_v(status, L"type", @"Local");
                break;
            case EKCalendarTypeCalDAV:
                ob_set_v(status, L"type", @"CalDAV");
                break;
            case EKCalendarTypeExchange:
                ob_set_v(status, L"type", @"Exchange");
                break;
            case EKCalendarTypeSubscription:
                ob_set_v(status, L"type", @"Subscription");
                break;
            case EKCalendarTypeBirthday:
                ob_set_v(status, L"type", @"Birthday");
                break;
            default:
                /* CalCalendarTypeIMAP not supported in EK */
                break;
        }
        
        ob_set_b(status, L"subscribed", calendar.subscribed);
        ob_set_b(status, L"immutable", calendar.immutable);
        ob_set_b(status, L"allowsContentModifications", calendar.allowsContentModifications);
        
        
    }
    
}

NSArray *ob_get_calendars(PA_ObjectRef options,
                          EKEventStore *calendarStore
                          ) {
    
    NSMutableArray *value = nil;
    
    if(options){
        if(calendarStore){
            PA_CollectionRef calendars = ob_get_c(options, L"calendars");
            if(calendars){
                value = [[NSMutableArray alloc]init];
                for(PA_long32 i = 0; i < PA_GetCollectionLength(calendars); ++i){
                    PA_Variable v = PA_GetCollectionElement(calendars, i);
                    if(PA_GetVariableKind(v) == eVK_Object){
                        PA_ObjectRef o = PA_GetObjectVariable(v);
                        if(o){
                            NSString *uid = ob_get_v(o, L"uid");
                            if(uid){
                                
                                EKCalendar *calendar = [calendarStore calendarWithIdentifier:uid];
                                
                                if(calendar){
                                    [value addObject:calendar];
                                }
                            }else{
                                NSString *title = ob_get_v(o, L"title");
                                if(title){
                                    
                                    NSArray *_calendars = [calendarStore calendarsForEntityType:EKEntityTypeEvent];
                                    
                                    NSPredicate *predicate = [NSPredicate predicateWithFormat:@"title LIKE %@", title];
                                    _calendars = [_calendars filteredArrayUsingPredicate:predicate];
                                    if([_calendars count]){
                                        [value addObject:[_calendars objectAtIndex:0]];
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    return value;
}

#pragma mark -

EKEvent *ob_get_event(PA_ObjectRef options,
                      EKEventStore *calendarStore
                      ) {
    
    EKEvent *value = nil;
    
    if(options){
        if(calendarStore){
            NSString *uid = ob_get_v(options, L"uid");
            if(uid){
                
                NSArray *values = [calendarStore calendarItemsWithExternalIdentifier:uid];
                if([values count]) {
                    value = [values objectAtIndex:0];
                }
                
            }
        }
    }
    return value;
}

EKCalendar *ob_get_calendar(PA_ObjectRef options,
                            EKEventStore     *calendarStore
                            ) {
    EKCalendar  *value = nil;
    if(options){
        if(calendarStore){
            NSString *uid = ob_get_v(options, L"uid");
            if(uid){
                value = [calendarStore calendarWithIdentifier:uid];
            }else{
                NSString *title = ob_get_v(options, L"title");
                if(title){
                    NSArray<EKCalendar *> *_calendars = [calendarStore calendarsForEntityType:EKEntityTypeEvent];
                    NSPredicate *predicate = [NSPredicate predicateWithFormat:@"title LIKE %@", title];
                    _calendars = [_calendars filteredArrayUsingPredicate:predicate];
                    if([_calendars count]){
                        value = [_calendars objectAtIndex:0];
                    }
                }
            }
        }
    }
    return value;
}

void ob_set_event_calendar(PA_ObjectRef status,
                           EKEvent *event
                           ) {
    
    if(status){
        
        PA_ObjectRef _calendar = PA_CreateObject();
        
        if(event){
            EKCalendar *calendar = event.calendar;
            if(calendar){
                ob_set_calendar(_calendar, calendar);
            }
        }
        
        ob_set_o(status, L"calendar", _calendar);
    }
}

void ob_set_event_prop(PA_ObjectRef status, PA_ObjectRef options,
                       EKEvent *event) {
    
    if(status){
        if(options){
            if(event){
                
                NSDate *startDate = ob_get_d(options, L"startDate");
                NSDate *endDate = ob_get_d(options, L"endDate");
                
                if(startDate){
                    if(endDate){
                        
                        event.startDate = startDate;
                        event.endDate = endDate;
                        
                        NSString *title = ob_get_v(options, L"title");
                        
                        if(title){
                            event.title = title;
                            [title release];
                        }
                        
                        NSString *location = ob_get_v(options, L"location");
                        
                        if(location){
                            event.location = location;
                            [location release];
                        }
                        
                        NSString *notes = ob_get_v(options, L"notes");
                        
                        if(notes){
                            event.notes = notes;
                            [notes release];
                        }
                        
                        if(ob_is_defined(options, L"isAllDay")){
                            event.allDay = ob_get_b(options, L"isAllDay");
                            
                            
                        }
                        
                        NSString *url = ob_get_v(options, L"url");
                        
                        if(url){
                            NSURL *_url = [[NSURL alloc]initWithString:url];
                            if(_url){
                                
                                event.URL = _url;
                                
                            }
                            [url release];
                        }
                        
                        if(ob_is_defined(options, L"recurrenceRule")){
                            
                            PA_ObjectRef _recurrenceRule = ob_get_o(options, L"recurrenceRule");
                            if(_recurrenceRule){
                                
                                EKRecurrenceEnd *recurrenceEnd = nil;
                                
                                
                                NSDate *endDate = nil;
                                NSUInteger occurrenceCount = 0;
                                NSUInteger recurrenceInterval = 0;
                                
                                EKRecurrenceFrequency recurrenceType = EKRecurrenceFrequencyDaily;
                                
                                
                                if(ob_is_defined(_recurrenceRule, L"recurrenceType")){
                                    
                                    recurrenceType = (EKRecurrenceFrequency)ob_get_n(_recurrenceRule, L"recurrenceType");
                                    
                                    
                                }
                                
                                if(ob_is_defined(_recurrenceRule, L"recurrenceInterval")){
                                    recurrenceInterval = (NSUInteger)ob_get_n(_recurrenceRule, L"recurrenceInterval");
                                }
                                
                                
                                if(ob_is_defined(_recurrenceRule, L"recurrenceEnd")){
                                    PA_ObjectRef _recurrenceEnd = ob_get_o(_recurrenceRule, L"recurrenceEnd");
                                    if(_recurrenceEnd){
                                        endDate = ob_get_d(_recurrenceEnd, L"endDate");
                                        occurrenceCount = ob_get_n(_recurrenceEnd, L"occurrenceCount");
                                        
                                        if(endDate) {
                                            recurrenceEnd = [EKRecurrenceEnd recurrenceEndWithEndDate:endDate];
                                        }
                                        
                                        if(occurrenceCount > 0) {
                                            recurrenceEnd = [EKRecurrenceEnd recurrenceEndWithOccurrenceCount:occurrenceCount];
                                        }
                                        
                                        
                                    }
                                    
                                }
                                
                                NSMutableArray *daysOfTheWeek = [[NSMutableArray alloc]init];
                                
                                if(ob_is_defined(_recurrenceRule, L"daysOfTheWeek")){
                                    PA_CollectionRef _daysOfTheWeek = ob_get_c(_recurrenceRule, L"daysOfTheWeek");
                                    if(_daysOfTheWeek){
                                        for(PA_long32 i = 0; i < PA_GetCollectionLength(_daysOfTheWeek); ++i){
                                            PA_Variable v = PA_GetCollectionElement(_daysOfTheWeek, i);
                                            if(PA_GetVariableKind(v) == eVK_Real){
                                                [daysOfTheWeek addObject:[NSNumber numberWithInt:(int)PA_GetRealVariable(v)]];
                                            }
                                        }
                                    }
                                }
                                
                                NSMutableArray *daysOfTheMonth = [[NSMutableArray alloc]init];
                                
                                if(ob_is_defined(_recurrenceRule, L"daysOfTheMonth")){
                                    PA_CollectionRef _daysOfTheMonth = ob_get_c(_recurrenceRule, L"daysOfTheMonth");
                                    if(_daysOfTheMonth){
                                        for(PA_long32 i = 0; i < PA_GetCollectionLength(_daysOfTheMonth); ++i){
                                            PA_Variable v = PA_GetCollectionElement(_daysOfTheMonth, i);
                                            if(PA_GetVariableKind(v) == eVK_Real){
                                                [daysOfTheMonth addObject:[NSNumber numberWithInt:(int)PA_GetRealVariable(v)]];
                                            }
                                        }
                                    }
                                }
                                
                                NSMutableArray *monthsOfTheYear = [[NSMutableArray alloc]init];
                                
                                if(ob_is_defined(_recurrenceRule, L"monthsOfTheYear")){
                                    PA_CollectionRef _monthsOfTheYear = ob_get_c(_recurrenceRule, L"monthsOfTheYear");
                                    if(_monthsOfTheYear){
                                        for(PA_long32 i = 0; i < PA_GetCollectionLength(_monthsOfTheYear); ++i){
                                            PA_Variable v = PA_GetCollectionElement(_monthsOfTheYear, i);
                                            if(PA_GetVariableKind(v) == eVK_Real){
                                                [monthsOfTheYear addObject:[NSNumber numberWithInt:(int)PA_GetRealVariable(v)]];
                                            }
                                        }
                                    }
                                }
                                
                                NSMutableArray *weeksOfTheYear = [[NSMutableArray alloc]init];
                                
                                if(ob_is_defined(_recurrenceRule, L"weeksOfTheYear")){
                                    PA_CollectionRef _weeksOfTheYear = ob_get_c(_recurrenceRule, L"weeksOfTheYear");
                                    if(_weeksOfTheYear){
                                        for(PA_long32 i = 0; i < PA_GetCollectionLength(_weeksOfTheYear); ++i){
                                            PA_Variable v = PA_GetCollectionElement(_weeksOfTheYear, i);
                                            if(PA_GetVariableKind(v) == eVK_Real){
                                                [weeksOfTheYear addObject:[NSNumber numberWithInt:(int)PA_GetRealVariable(v)]];
                                            }
                                        }
                                    }
                                }
                                
                                NSMutableArray *daysOfTheYear = [[NSMutableArray alloc]init];
                                
                                if(ob_is_defined(_recurrenceRule, L"daysOfTheYear")){
                                    PA_CollectionRef _daysOfTheYear = ob_get_c(_recurrenceRule, L"daysOfTheYear");
                                    if(_daysOfTheYear){
                                        for(PA_long32 i = 0; i < PA_GetCollectionLength(_daysOfTheYear); ++i){
                                            PA_Variable v = PA_GetCollectionElement(_daysOfTheYear, i);
                                            if(PA_GetVariableKind(v) == eVK_Real){
                                                [daysOfTheYear addObject:[NSNumber numberWithInt:(int)PA_GetRealVariable(v)]];
                                            }
                                        }
                                    }
                                }
                                
                                NSMutableArray *setPositions = [[NSMutableArray alloc]init];
                                
                                if(ob_is_defined(_recurrenceRule, L"setPositions")){
                                    PA_CollectionRef _setPositions = ob_get_c(_recurrenceRule, L"setPositions");
                                    if(_setPositions){
                                        for(PA_long32 i = 0; i < PA_GetCollectionLength(_setPositions); ++i){
                                            PA_Variable v = PA_GetCollectionElement(_setPositions, i);
                                            if(PA_GetVariableKind(v) == eVK_Real){
                                                [setPositions addObject:[NSNumber numberWithInt:(int)PA_GetRealVariable(v)]];
                                            }
                                        }
                                    }
                                }
                                
                                EKRecurrenceRule *recurrenceRule = [[EKRecurrenceRule alloc]initRecurrenceWithFrequency:recurrenceType
                                                                                                               interval:recurrenceInterval
                                                                                                          daysOfTheWeek:[daysOfTheWeek count] ? daysOfTheWeek : nil
                                                                                                         daysOfTheMonth:[daysOfTheMonth count] ? daysOfTheMonth : nil
                                                                                                        monthsOfTheYear:[monthsOfTheYear count] ? monthsOfTheYear : nil
                                                                                                         weeksOfTheYear:[weeksOfTheYear count] ? weeksOfTheYear : nil
                                                                                                          daysOfTheYear:[daysOfTheYear count] ? daysOfTheYear : nil
                                                                                                           setPositions:[setPositions count] ? setPositions : nil
                                                                                                                    end:recurrenceEnd];
                                if(recurrenceRule) {
                                    [event addRecurrenceRule:recurrenceRule];
                                    [recurrenceRule release];
                                }
                                
                                
                                [daysOfTheWeek release];
                                [daysOfTheMonth release];
                                [monthsOfTheYear release];
                                
                                [weeksOfTheYear release];
                                [daysOfTheYear release];
                                [setPositions release];
                                
                            } else {
                                
                                if([event hasRecurrenceRules]) {
                                    NSArray<EKRecurrenceRule *> *recurrenceRules = event.recurrenceRules;
                                    if(recurrenceRules) {
                                        if(recurrenceRules.count > 0) {
                                            EKRecurrenceRule *recurrenceRule = recurrenceRules.firstObject;
                                            [event removeRecurrenceRule:recurrenceRule];
                                        }
                                    }
                                }
                            }
                        }
                        
                    }else{
                        ob_set_b(status, L"success", false);
                        ob_set_s(status, L"errorMessage", "invalid endDate");
                    }
                }else{
                    ob_set_b(status, L"success", false);
                    ob_set_s(status, L"errorMessage", "invalid startDate");
                }
            }
        }
    }
}

void ob_copy_event(PA_ObjectRef _event,
                   EKEvent *event,
                   BOOL with_calendar = TRUE) {
    
    if(_event){
        if(event){
            
            /*
            NSManagedObject *entity = static_cast<NSManagedObject *>(event);
            NSManagedObjectID *objectID = [entity objectID];
            NSString *URIRepresentation = [[objectID URIRepresentation]absoluteString];
            ob_set_v(_event, L"URIRepresentation", URIRepresentation);
            */
            
            ob_set_v(_event, L"uid", event.calendarItemExternalIdentifier);
            ob_set_u(_event, L"url", event.URL);
            ob_set_d(_event, L"occurrence", event.occurrenceDate);
            ob_set_d(_event, L"dateStamp", event.lastModifiedDate);
            ob_set_d(_event, L"creationDate", event.creationDate);
            
            if(event.timeZone) {
                
                NSTimeZone *timezone = event.timeZone;
                
                PA_ObjectRef _timeZone = PA_CreateObject();
                
                ob_set_v(_timeZone, L"name", timezone.name);
                ob_set_v(_timeZone, L"abbreviation", timezone.abbreviation);
                ob_set_b(_timeZone, L"daylightSavingTime", timezone.daylightSavingTime);
                ob_set_n(_timeZone, L"daylightSavingTimeOffset", timezone.daylightSavingTimeOffset);
                ob_set_n(_timeZone, L"secondsFromGMT", timezone.secondsFromGMT);
                ob_set_d(_timeZone, L"nextDaylightSavingTimeTransition", timezone.nextDaylightSavingTimeTransition);
                
                ob_set_o(_event, L"timeZone", _timeZone);
                
            }else{
                ob_set_0(_event, L"timeZone");
            }
            
            ob_set_v(_event, L"location", event.location);
            ob_set_v(_event, L"notes", event.notes);
            ob_set_v(_event, L"title", event.title);
            
            ob_set_d(_event, L"endDate", event.endDate);
            ob_set_d(_event, L"startDate", event.startDate);
            
            ob_set_b(_event, L"isAllDay", event.isAllDay);
            ob_set_b(_event, L"isDetached", event.isDetached);
            
            if(with_calendar){
                ob_set_event_calendar(_event, event);
            }
            
            NSArray *alarms = [event alarms];
            
            if(alarms){
                
                PA_CollectionRef _alarms = PA_CreateCollection();
                
                for(unsigned int i = 0; i < [alarms count]; ++i)
                {
                    
                    if([[alarms objectAtIndex:i]isMemberOfClass:[EKAlarm class]])
                    {
                        EKAlarm *alarm = [alarms objectAtIndex:i];
                        
                        PA_ObjectRef _alarm = PA_CreateObject();
                        
                        switch (alarm.type) {
                            case EKAlarmTypeAudio:
                                ob_set_v(_alarm, L"action", @"Sound"); /* CalAlarmActionSound, not "Audio" */
                                break;
                            case EKAlarmTypeDisplay:
                                ob_set_v(_alarm, L"action", @"Display");
                                break;
                            case EKAlarmTypeEmail:
                                ob_set_v(_alarm, L"action", @"Email");
                                break;
                            case EKAlarmTypeProcedure:
                                ob_set_v(_alarm, L"action", @"Procedure");
                                break;
                        }
                        
                        ob_set_v(_alarm, L"emailAddress", alarm.emailAddress);
                        ob_set_v(_alarm, L"sound", alarm.soundName);
                        
                        if(alarm.relativeOffset){
                            ob_set_n(_alarm, L"relativeTrigger", alarm.relativeOffset);
                        }else{
                            ob_set_0(_alarm, L"relativeTrigger");
                        }
                        
                        ob_set_d(_alarm, L"absoluteTrigger", alarm.absoluteDate);
                        
                        PA_Variable v = PA_CreateVariable(eVK_Object);
                        PA_SetObjectVariable(&v, _alarm);
                        PA_SetCollectionElement(_alarms, PA_GetCollectionLength(_alarms), v);
                        PA_ClearVariable(&v);
                    }
                    
                    
                }
                
                ob_set_c(_event, L"alarms", _alarms);
            }
            
            NSArray *attendees = [event attendees];
            
            if(attendees){
                
                PA_CollectionRef _attendees = PA_CreateCollection();
                
                for(unsigned int i = 0; i < [attendees count]; ++i)
                {
                    
                    if([[attendees objectAtIndex:i]isMemberOfClass:[EKParticipant class]])
                    {
                        EKParticipant *attendee = [attendees objectAtIndex:i];
                        
                        PA_ObjectRef _attendee = PA_CreateObject();
                        
                        ob_set_b(_attendee, L"isCurrentUser", attendee.currentUser);
                        
                        switch (attendee.participantRole) {
                            case EKParticipantRoleNonParticipant:
                                ob_set_v(_attendee, L"role", @"NonParticipant");
                                break;
                            case EKParticipantRoleChair:
                                ob_set_v(_attendee, L"role", @"Chair");
                                break;
                            case EKParticipantRoleOptional:
                                ob_set_v(_attendee, L"role", @"Optional");
                                break;
                            case EKParticipantRoleRequired:
                                ob_set_v(_attendee, L"role", @"Required");
                                break;
                            case EKParticipantRoleUnknown:
                            default:
                                ob_set_v(_attendee, L"role", @"Unknown");
                                break;
                        }
                        
                        switch (attendee.participantType) {
                            case EKParticipantTypeResource:
                                ob_set_v(_attendee, L"type", @"Resource");
                                break;
                            case EKParticipantTypeRoom:
                                ob_set_v(_attendee, L"type", @"Room");
                                break;
                            case EKParticipantTypePerson:
                                ob_set_v(_attendee, L"type", @"Person");
                                break;
                            case EKParticipantTypeGroup:
                                ob_set_v(_attendee, L"type", @"Group");
                                break;
                            case EKParticipantTypeUnknown:
                            default:
                                ob_set_v(_attendee, L"type", @"Unknown");
                                break;
                        }
                        
                        switch (attendee.participantStatus) {
                            case EKParticipantStatusPending:
                                ob_set_v(_attendee, L"status", @"Pending");
                                break;
                            case EKParticipantStatusAccepted:
                                ob_set_v(_attendee, L"status", @"Accepted");
                                break;
                            case EKParticipantStatusDeclined:
                                ob_set_v(_attendee, L"status", @"Declined");
                                break;
                            case EKParticipantStatusTentative:
                                ob_set_v(_attendee, L"status", @"Tentative");
                                break;
                            case EKParticipantStatusDelegated:
                                ob_set_v(_attendee, L"status", @"Delegated");
                                break;
                            case EKParticipantStatusCompleted:
                                ob_set_v(_attendee, L"status", @"Completed");
                                break;
                            case EKParticipantStatusInProcess:
                                ob_set_v(_attendee, L"status", @"InProcess");
                                break;
                            case EKParticipantStatusUnknown:
                            default:
                                ob_set_v(_attendee, L"status", @"Unknown");
                                break;
                        }
                        
                        ob_set_v(_attendee, L"commonName", attendee.name);
                        ob_set_u(_attendee, L"address", attendee.URL);
                        
                        PA_Variable v = PA_CreateVariable(eVK_Object);
                        PA_SetObjectVariable(&v, _attendee);
                        PA_SetCollectionElement(_attendees, PA_GetCollectionLength(_attendees), v);
                        PA_ClearVariable(&v);
                    }
                    
                    
                    
                }
                
                ob_set_c(_event, L"attendees", _attendees);
            }
            
            EKRecurrenceRule *recurrenceRule = nil;
            if([event hasRecurrenceRules]) {
                NSArray<EKRecurrenceRule *> *recurrenceRules = event.recurrenceRules;
                if(recurrenceRules) {
                    if(recurrenceRules.count > 0) {
                        recurrenceRule = recurrenceRules.firstObject;
                    }
                }
            }
            
            if(recurrenceRule){
                
                PA_ObjectRef _recurrenceRule = PA_CreateObject();
                ob_set_n(_recurrenceRule, L"recurrenceInterval", recurrenceRule.interval);
                ob_set_n(_recurrenceRule, L"recurrenceType", recurrenceRule.frequency);
                
                ob_set_n(_recurrenceRule, L"firstDayOfTheWeek", recurrenceRule.firstDayOfTheWeek);
                
                PA_ObjectRef _recurrenceEnd = PA_CreateObject();
                
                if(recurrenceRule.recurrenceEnd){
                    
                    ob_set_d(_recurrenceEnd, L"endDate", recurrenceRule.recurrenceEnd.endDate);
                    ob_set_n(_recurrenceEnd, L"occurrenceCount", recurrenceRule.recurrenceEnd.occurrenceCount);
                }
                
                ob_set_o(_recurrenceRule, L"recurrenceEnd", _recurrenceEnd);
                
                if(recurrenceRule.daysOfTheWeek){
                    PA_CollectionRef _daysOfTheWeek = PA_CreateCollection();
                    for(unsigned int i = 0; i < [recurrenceRule.daysOfTheWeek count]; ++i)
                    {
                        EKRecurrenceDayOfWeek *daysOfTheWeek = [recurrenceRule.daysOfTheWeek objectAtIndex:i];
                        if(daysOfTheWeek) {
                            PA_Variable v = PA_CreateVariable(eVK_Longint);
                            EKWeekday dayOfTheWeek = [daysOfTheWeek dayOfTheWeek];
                            PA_SetLongintVariable(&v, (PA_long32)dayOfTheWeek);
                            PA_SetCollectionElement(_daysOfTheWeek, PA_GetCollectionLength(_daysOfTheWeek), v);
                            PA_ClearVariable(&v);
                        }
                    }
                    ob_set_c(_recurrenceRule, L"daysOfTheWeek", _daysOfTheWeek);
                }
                
                if(recurrenceRule.daysOfTheMonth){
                    PA_CollectionRef _daysOfTheMonth = PA_CreateCollection();
                    for(unsigned int i = 0; i < [recurrenceRule.daysOfTheMonth count]; ++i)
                    {
                        NSNumber *daysOfTheMonth = [recurrenceRule.daysOfTheMonth objectAtIndex:i];
                        if(daysOfTheMonth) {
                            PA_Variable v = PA_CreateVariable(eVK_Longint);
                            PA_SetLongintVariable(&v, (PA_long32)[daysOfTheMonth intValue]);
                            PA_SetCollectionElement(_daysOfTheMonth, PA_GetCollectionLength(_daysOfTheMonth), v);
                            PA_ClearVariable(&v);
                        }
                    }
                    ob_set_c(_recurrenceRule, L"daysOfTheMonth", _daysOfTheMonth);
                }
                
                if(recurrenceRule.monthsOfTheYear){
                    PA_CollectionRef _monthsOfTheYear = PA_CreateCollection();
                    for(unsigned int i = 0; i < [recurrenceRule.monthsOfTheYear count]; ++i)
                    {
                        NSNumber *monthsOfTheYear = [recurrenceRule.monthsOfTheYear objectAtIndex:i];
                        if(monthsOfTheYear) {
                            PA_Variable v = PA_CreateVariable(eVK_Longint);
                            PA_SetLongintVariable(&v, (PA_long32)[monthsOfTheYear intValue]);
                            PA_SetCollectionElement(_monthsOfTheYear, PA_GetCollectionLength(_monthsOfTheYear), v);
                            PA_ClearVariable(&v);
                        }
                    }
                    ob_set_c(_recurrenceRule, L"monthsOfTheYear", _monthsOfTheYear);
                }
                
                if(recurrenceRule.daysOfTheYear){
                    PA_CollectionRef _daysOfTheYear = PA_CreateCollection();
                    for(unsigned int i = 0; i < [recurrenceRule.daysOfTheYear count]; ++i)
                    {
                        NSNumber *daysOfTheYear = [recurrenceRule.daysOfTheYear objectAtIndex:i];
                        if(daysOfTheYear) {
                            PA_Variable v = PA_CreateVariable(eVK_Longint);
                            PA_SetLongintVariable(&v, (PA_long32)[daysOfTheYear intValue]);
                            PA_SetCollectionElement(_daysOfTheYear, PA_GetCollectionLength(_daysOfTheYear), v);
                            PA_ClearVariable(&v);
                        }
                    }
                    ob_set_c(_recurrenceRule, L"daysOfTheYear", _daysOfTheYear);
                }
                
                if(recurrenceRule.weeksOfTheYear){
                    PA_CollectionRef _weeksOfTheYear = PA_CreateCollection();
                    for(unsigned int i = 0; i < [recurrenceRule.weeksOfTheYear count]; ++i)
                    {
                        NSNumber *weeksOfTheYear = [recurrenceRule.weeksOfTheYear objectAtIndex:i];
                        if(weeksOfTheYear) {
                            PA_Variable v = PA_CreateVariable(eVK_Longint);
                            PA_SetLongintVariable(&v, (PA_long32)[weeksOfTheYear intValue]);
                            PA_SetCollectionElement(_weeksOfTheYear, PA_GetCollectionLength(_weeksOfTheYear), v);
                            PA_ClearVariable(&v);
                        }
                    }
                    ob_set_c(_recurrenceRule, L"weeksOfTheYear", _weeksOfTheYear);
                }
                
                if(recurrenceRule.setPositions){
                    PA_CollectionRef _setPositions = PA_CreateCollection();
                    for(unsigned int i = 0; i < [recurrenceRule.setPositions count]; ++i)
                    {
                        NSNumber *setPositions = [recurrenceRule.setPositions objectAtIndex:i];
                        if(setPositions) {
                            PA_Variable v = PA_CreateVariable(eVK_Longint);
                            PA_SetLongintVariable(&v, (PA_long32)[setPositions intValue]);
                            PA_SetCollectionElement(_setPositions, PA_GetCollectionLength(_setPositions), v);
                            PA_ClearVariable(&v);
                        }
                    }
                    ob_set_c(_recurrenceRule, L"setPositions", _setPositions);
                }
                
                
                ob_set_o(_event, L"recurrenceRule", _recurrenceRule);
            }
        }
    }
}

void ob_set_error(PA_ObjectRef status, NSError *error) {
    
    if(status){
        if(error){
            ob_set_b(status, L"success", false);
            
            PA_ObjectRef _error = PA_CreateObject();
            
            ob_set_n(_error, L"code", error.code);
            ob_set_v(_error, L"localizedDescription", error.localizedDescription);
            ob_set_v(_error, L"localizedRecoverySuggestion", error.localizedRecoverySuggestion);
            ob_set_o(status, L"error", _error);
        }
    }
}

void ob_add_event(PA_CollectionRef _events,
                  EKEvent *event) {
    
    if(_events){
        if(event){
            PA_ObjectRef _event = PA_CreateObject();
            ob_copy_event(_event, event);
            
            PA_Variable v = PA_CreateVariable(eVK_Object);
            PA_SetObjectVariable(&v, _event);
            PA_SetCollectionElement(_events, PA_GetCollectionLength(_events), v);
            PA_ClearVariable(&v);
        }
    }
}

void ob_set_event(PA_ObjectRef status,
                  EKEvent *event
                  ) {
    
    if(status){
        if(event){
            PA_ObjectRef _event = PA_CreateObject();
            ob_copy_event(_event, event);
            
            ob_set_o(status, L"event", _event);
        }
    }
}

#pragma mark Event

void iCal_Create_event(PA_PluginParameters params) {
    
    PA_ObjectRef status = PA_CreateObject();
    
    if(check_permission(status)) {
        
        EKSpan span = EKSpanFutureEvents;
        
        defaultCalendarStore = _getDefaultCalendarStore();
        
        if(defaultCalendarStore) {
            PA_ObjectRef options = PA_GetObjectParameter(params, 1);
            if(options){
                
                if(ob_is_defined(options, L"span")) {
                    CUTF8String _span;
                    if(ob_get_s(options, L"span", &_span)) {
                        if(_span == (const uint8_t *)"future") {
                            span = EKSpanFutureEvents;
                        }
                        if(_span == (const uint8_t *)"this") {
                            span = EKSpanThisEvent;
                        }
                    }
                }
                
                PA_ObjectRef c = ob_get_o(options, L"calendar");
                
                if(c){
                    
                    EKCalendar  *calendar = ob_get_calendar(c, defaultCalendarStore);
                    
                    if(calendar){
                        
                        EKEvent  *event = [EKEvent eventWithEventStore:defaultCalendarStore];
                        
                        event.calendar = calendar;
                        
                        ob_set_event_prop(status, options, event);
                        
                        NSError *error = nil;
                        
                        if([defaultCalendarStore saveEvent:event span:span  commit:YES error:&error]) {
                            
                            ob_set_b(status, L"success", true);
                            ob_set_event(status, event);
                            
                        }else{
                            ob_set_error(status, error);
                        }
                    }else{
                        ob_set_b(status, L"success", false);
                        ob_set_s(status, L"errorMessage", "invalid calendar");
                    }
                }else{
                    ob_set_b(status, L"success", false);
                    ob_set_s(status, L"errorMessage", "calendar option is missing");
                }
            }else{
                ob_set_b(status, L"success", false);
                ob_set_s(status, L"errorMessage", "option is missing");
            }
        }
    }
    PA_ReturnObject(params, status);
}

void iCal_Set_event_property(PA_PluginParameters params) {
    
    PA_ObjectRef status = PA_CreateObject();
    
    if(check_permission(status)) {
        
        EKSpan span = EKSpanFutureEvents;
        
        defaultCalendarStore = _getDefaultCalendarStore();
        
        if(defaultCalendarStore) {
            PA_ObjectRef options = PA_GetObjectParameter(params, 1);
            if(options){
                
                if(ob_is_defined(options, L"span")) {
                    CUTF8String _span;
                    if(ob_get_s(options, L"span", &_span)) {
                        if(_span == (const uint8_t *)"future") {
                            span = EKSpanFutureEvents;
                        }
                        if(_span == (const uint8_t *)"this") {
                            span = EKSpanThisEvent;
                        }
                    }
                }
                
                EKEvent  *event = ob_get_event(options, defaultCalendarStore);
                
                if(event){
                    
                    PA_ObjectRef c = ob_get_o(options, L"calendar");
                    
                    if(c){
                        
                        EKCalendar  *calendar = ob_get_calendar(c, defaultCalendarStore);
                        
                        if(calendar){
                            event.calendar = calendar;
                        }
                    }
                    
                    ob_set_event_prop(status, options, event);
                    
                    NSError *error = nil;
                    
                    if([defaultCalendarStore saveEvent:event span:span     commit:YES error:&error]) {
                        
                        ob_set_b(status, L"success", true);
                        ob_set_event(status, event);
                        
                    }else{
                        ob_set_error(status, error);
                    }
                }else{
                    ob_set_b(status, L"success", false);
                    ob_set_s(status, L"errorMessage", "invalid event");
                }
                
            }else{
                ob_set_b(status, L"success", false);
                ob_set_s(status, L"errorMessage", "option is missing");
            }
        }
    }
    PA_ReturnObject(params, status);
}

void iCal_Get_event_property(PA_PluginParameters params) {
    
    PA_ObjectRef status = PA_CreateObject();
    
    if(check_permission(status)) {
        
        defaultCalendarStore = _getDefaultCalendarStore();
        
        if(defaultCalendarStore) {
            PA_ObjectRef options = PA_GetObjectParameter(params, 1);
            if(options){
                
                EKEvent  *event = ob_get_event(options, defaultCalendarStore);
                
                if(event){
                    
                    ob_set_b(status, L"success", true);
                    ob_set_event(status, event);
                    
                }else{
                    ob_set_b(status, L"success", false);
                    ob_set_s(status, L"errorMessage", "invalid event");
                }
                
            }else{
                ob_set_b(status, L"success", false);
                ob_set_s(status, L"errorMessage", "option is missing");
            }
        }
    }
    PA_ReturnObject(params, status);
}

void iCal_Remove_event(PA_PluginParameters params) {
    
    PA_ObjectRef status = PA_CreateObject();
    
    if(check_permission(status)) {
        
        EKSpan span = EKSpanFutureEvents;
        
        defaultCalendarStore = _getDefaultCalendarStore();
        
        if(defaultCalendarStore) {
            PA_ObjectRef options = PA_GetObjectParameter(params, 1);
            if(options){
                
                EKEvent  *event = ob_get_event(options, defaultCalendarStore);
                
                if(ob_is_defined(options, L"span")) {
                    CUTF8String _span;
                    if(ob_get_s(options, L"span", &_span)) {
                        if(_span == (const uint8_t *)"future") {
                            span = EKSpanFutureEvents;
                        }
                        if(_span == (const uint8_t *)"this") {
                            span = EKSpanThisEvent;
                        }
                    }
                }
                
                if(event){
                    
                    NSError *error = nil;
                    
                    if([defaultCalendarStore removeEvent:event span:span  commit:YES error:&error]) {
                        
                        ob_set_b(status, L"success", true);
                    }else{
                        ob_set_error(status, error);
                    }
                }else{
                    ob_set_b(status, L"success", false);
                    ob_set_s(status, L"errorMessage", "invalid event");
                }
                
            }else{
                ob_set_b(status, L"success", false);
                ob_set_s(status, L"errorMessage", "option is missing");
            }
        }
    }
    PA_ReturnObject(params, status);
}

#pragma mark Calendar

void iCal_Create_calendar(PA_PluginParameters params) {
    
    PA_ObjectRef status = PA_CreateObject();
    
    if(check_permission(status)) {
        
        defaultCalendarStore = _getDefaultCalendarStore();
        
        if(defaultCalendarStore) {
            PA_ObjectRef options = PA_GetObjectParameter(params, 1);
            if(options){
                
                EKCalendar  *calendar = [EKCalendar calendarForEntityType:EKEntityTypeEvent eventStore:defaultCalendarStore];
                
                if(calendar) {
                    
                    NSString *title = ob_get_v(options, L"title");
                    
                    if(title){
                        calendar.title = title;
                        [title release];
                    }
                    
                    NSArray<EKSource *> *sources = [defaultCalendarStore sources];
                    NSString *source = ob_get_v(options, L"source");
                    
                    if(source) {
                        
                        if(!calendar.source) {
                            calendar.source = [defaultCalendarStore sourceWithIdentifier:source];
                        }
                        
                        if(!calendar.source) {
                            NSPredicate *predicate = [NSPredicate predicateWithFormat:@"%K == %@ or %K LIKE %@",
                                                      @"typeString", source, @"title", source
                            ];
                            NSArray *_sources = [sources filteredArrayUsingPredicate:predicate];
                            if([_sources count]){
                                calendar.source = [_sources objectAtIndex:0];
                            }
                        }
                        
                        [source release];
                    }
                    
                    if(!calendar.source) {
                        calendar.source = [defaultCalendarStore sourceWithIdentifier:@"Local"];
                    }
                    
                    if(!calendar.source) {
                        NSPredicate *predicate = [NSPredicate predicateWithFormat:@"%K == %@",
                                                  @"sourceType", [NSNumber numberWithInt:EKSourceTypeLocal]];
                        NSArray *_sources = [sources filteredArrayUsingPredicate:predicate];
                        if([_sources count]){
                            calendar.source = [_sources objectAtIndex:0];
                        }
                    }
                    
                    if(ob_is_defined(options, L"color")){
                        calendar.color = getRGBcolor(ob_get_n(options, L"color"));
                    }
                    
                    NSError *error = nil;
                    
                    if([defaultCalendarStore saveCalendar:calendar commit:YES error:&error])
                        
                    {
                        ob_set_b(status, L"success", true);
                        
                        PA_ObjectRef _calendar = PA_CreateObject();
                        
                        ob_set_calendar(_calendar, calendar);
                        
                        ob_set_o(status, L"calendar", _calendar);
                        
                    }else{
                        ob_set_error(status, error);
                    }
                    
                }
                
            }else{
                ob_set_b(status, L"success", false);
                ob_set_s(status, L"errorMessage", "option is missing");
            }
        }
    }
    
    PA_ReturnObject(params, status);
}

void iCal_Set_calendar_property(PA_PluginParameters params) {
    
    PA_ObjectRef status = PA_CreateObject();
    
    if(check_permission(status)) {
        
        defaultCalendarStore = _getDefaultCalendarStore();
        
        if(defaultCalendarStore) {
            PA_ObjectRef options = PA_GetObjectParameter(params, 1);
            if(options){
                
                EKCalendar  *calendar = ob_get_calendar(options, defaultCalendarStore);
                
                if(calendar){
                    
                    NSString *title = ob_get_v(options, L"title");
                    
                    if(title){
                        calendar.title = title;
                        [title release];
                    }
                    
                    if(ob_is_defined(options, L"color")){
                        calendar.color = getRGBcolor(ob_get_n(options, L"color"));
                    }
                    
                    NSError *error = nil;
                    
                    if([defaultCalendarStore saveCalendar:calendar commit:YES error:&error]) {
                        
                        ob_set_b(status, L"success", true);
                        
                        PA_ObjectRef _calendar = PA_CreateObject();
                        
                        ob_set_calendar(_calendar, calendar);
                        
                        ob_set_o(status, L"calendar", _calendar);
                        
                    }else{
                        ob_set_error(status, error);
                    }
                }else{
                    ob_set_b(status, L"success", false);
                    ob_set_s(status, L"errorMessage", "invalid calendar");
                }
            }else{
                ob_set_b(status, L"success", false);
                ob_set_s(status, L"errorMessage", "option is missing");
            }
        }
    }
    
    PA_ReturnObject(params, status);
}

void iCal_Get_calendar_property(PA_PluginParameters params) {
    
    PA_ObjectRef status = PA_CreateObject();
    
    if(check_permission(status)) {
        
        defaultCalendarStore = _getDefaultCalendarStore();
        
        if(defaultCalendarStore) {
            PA_ObjectRef options = PA_GetObjectParameter(params, 1);
            if(options){
                
                EKCalendar *calendar = ob_get_calendar(options, defaultCalendarStore);
                
                if(calendar){
                    
                    PA_ObjectRef _calendar = PA_CreateObject();
                    
                    ob_set_calendar(_calendar, calendar);
                    
                    ob_set_o(status, L"calendar", _calendar);
                }else{
                    ob_set_b(status, L"success", false);
                    ob_set_s(status, L"errorMessage", "invalid calendar");
                }
            }else{
                ob_set_b(status, L"success", false);
                ob_set_s(status, L"errorMessage", "option is missing");
            }
        }
    }
    
    PA_ReturnObject(params, status);
}

void iCal_Remove_calendar(PA_PluginParameters params) {
    
    PA_ObjectRef status = PA_CreateObject();
    
    if(check_permission(status)) {
        
        defaultCalendarStore = _getDefaultCalendarStore();
        
        if(defaultCalendarStore) {
            PA_ObjectRef options = PA_GetObjectParameter(params, 1);
            if(options){
                
                EKCalendar *calendar = ob_get_calendar(options, defaultCalendarStore);
                
                if(calendar){
                    NSError *error = nil;
                    
                    if([defaultCalendarStore removeCalendar:calendar commit:YES error:&error]) {
                        ob_set_b(status, L"success", true);
                    }else{
                        ob_set_error(status, error);
                    }
                }else{
                    ob_set_b(status, L"success", false);
                    ob_set_s(status, L"errorMessage", "invalid calendar");
                }
            }else{
                ob_set_b(status, L"success", false);
                ob_set_s(status, L"errorMessage", "option is missing");
            }
        }
    }
    PA_ReturnObject(params, status);
}

static NSString *eventForObject(NSString *objectID) {
    
    defaultCalendarStore = _getDefaultCalendarStore();
    
    //Apple now seems to limit the span between startDate and endDate to 4 years
    NSDate *now = [NSDate date];
    NSCalendar *currentCalendar = [NSCalendar currentCalendar];
    NSDateComponents *years = [[NSDateComponents alloc]init];
    years.year = 1;
    NSDate *endDate = [currentCalendar dateByAddingComponents:years toDate:now options:0];
    years.year = -3;
    NSDate *startDate = [currentCalendar dateByAddingComponents:years toDate:now options:0];
    [years release];
    
    NSPredicate *predicate = [defaultCalendarStore predicateForEventsWithStartDate:startDate
                                                                           endDate:endDate
                                                                         calendars:nil];
    if(predicate){
        
        NSArray *events = [defaultCalendarStore eventsMatchingPredicate:predicate];
        
        time_t startTime = time(0);
        
        for(unsigned int i = 0; i < [events count]; ++i) {
            
            time_t now = time(0);
            time_t elapsedTime = abs(startTime - now);
            if(elapsedTime > 0)
            {
                startTime = now;
                PA_YieldAbsolute();
            }
            if([[events objectAtIndex:i]isMemberOfClass:[EKEvent class]]) {
                EKEvent *event = [events objectAtIndex:i];
                NSManagedObject *entity = static_cast<NSManagedObject *>(event);
                NSString *URIRepresentation = [[[entity objectID]URIRepresentation]absoluteString];
                if([URIRepresentation isEqualToString:objectID]) {
                    return [event calendarItemExternalIdentifier];
                }
            }
        }
    }
    return nil;
}

void iCal_QUERY_EVENT(PA_PluginParameters params) {
    
    PA_ObjectRef status = PA_CreateObject();
    
    if(check_permission(status)) {
        
        defaultCalendarStore = _getDefaultCalendarStore();
        
        if(defaultCalendarStore) {
            
            PA_CollectionRef _events = PA_CreateCollection();
            
            PA_ObjectRef options = PA_GetObjectParameter(params, 1);
            if(options){
                
                NSDate *startDate = ob_get_d(options, L"startDate");
                NSDate *endDate = ob_get_d(options, L"endDate");
                
                if(startDate){
                    if(endDate){
                        
                        NSArray *calendars = ob_get_calendars(options, defaultCalendarStore);
                        
                        NSPredicate *predicate = [defaultCalendarStore predicateForEventsWithStartDate:startDate
                                                  
                                                                                               endDate:endDate
                                                                                             calendars:[calendars count] ? calendars : nil];
                        
                        if(predicate){
                            NSArray *events = [defaultCalendarStore eventsMatchingPredicate:predicate];
                            
                            time_t startTime = time(0);
                            
                            for(unsigned int i = 0; i < [events count]; ++i) {
                                
                                time_t now = time(0);
                                time_t elapsedTime = abs(startTime - now);
                                if(elapsedTime > 0)
                                {
                                    startTime = now;
                                    PA_YieldAbsolute();
                                }
                                if([[events objectAtIndex:i]isMemberOfClass:[EKEvent class]]) {
                                    EKEvent *event = [events objectAtIndex:i];
                                    ob_add_event(_events, event);
                                }
                            }
                            
                            ob_set_c(status, L"events", _events);
                        }else{
                            ob_set_b(status, L"success", false);
                            ob_set_s(status, L"errorMessage", "invalid predicate");
                        }
                        
                        if(calendars) {
                            [calendars release];
                        }
                        
                    }else{
                        ob_set_b(status, L"success", false);
                        ob_set_s(status, L"errorMessage", "invalid endDate");
                    }
                }else{
                    ob_set_b(status, L"success", false);
                    ob_set_s(status, L"errorMessage", "invalid startDate");
                }
            }
        }
    }
    PA_ReturnObject(params, status);
}

void iCal_GET_CALENDAR_LIST(PA_PluginParameters params) {
    
    PA_ObjectRef status = PA_CreateObject();
    
    if(check_permission(status)) {
        
        defaultCalendarStore = _getDefaultCalendarStore();
        
        if(defaultCalendarStore) {
            
            PA_CollectionRef _calendars = PA_CreateCollection();
            
            NSArray *calendars = [defaultCalendarStore calendarsForEntityType:EKEntityTypeEvent];
            
            for(unsigned int i = 0; i < [calendars count]; ++i) {
                
                if([[calendars objectAtIndex:i]isMemberOfClass:[EKCalendar class]]) {
                    
                    EKCalendar *calendar = [calendars objectAtIndex:i];
                    PA_ObjectRef _calendar = PA_CreateObject();
                    
                    ob_set_calendar(_calendar, calendar);
                    
                    PA_Variable v = PA_CreateVariable(eVK_Object);
                    PA_SetObjectVariable(&v, _calendar);
                    PA_SetCollectionElement(_calendars, PA_GetCollectionLength(_calendars), v);
                    PA_ClearVariable(&v);
                }
                
            }
            
            ob_set_c(status, L"calendars", _calendars);
            
        }
    }
    
    PA_ReturnObject(params, status);
}

void iCal_Get_default_calendar(PA_PluginParameters params) {
    
    PA_ObjectRef status = PA_CreateObject();
    
    if(check_permission(status)) {
        
        defaultCalendarStore = _getDefaultCalendarStore();
        
        if(defaultCalendarStore) {
            
            NSArray<EKSource *> *delegateSources = [defaultCalendarStore delegateSources];
            
            EKCalendar *calendar = defaultCalendarStore.defaultCalendarForNewEvents;
            
            if(calendar) {
                
                ob_set_b(status, L"success", true);
                
                PA_ObjectRef _calendar = PA_CreateObject();
                
                ob_set_calendar(_calendar, calendar);
                
                ob_set_o(status, L"calendar", _calendar);
                
                NSArray<EKSource *> *sources = [defaultCalendarStore sources];
                
                PA_CollectionRef _sources = PA_CreateCollection();
                
                for(NSUInteger i = 0; i < [sources count]; ++i) {
                    
                    EKSource *source = [sources objectAtIndex:i];
                    
                    PA_ObjectRef s = PA_CreateObject();
                    
                    if (@available(macOS 13.0, *)) {
                        ob_set_b(s, L"isDelegate", source.isDelegate);
                    }
                    
                    ob_set_v(s, L"uid", source.sourceIdentifier);
                    ob_set_v(s, L"title", source.title);
                    
                    switch (source.sourceType) {
                        case EKSourceTypeLocal:
                            ob_set_v(s, L"type", @"Local");
                            break;
                        case EKSourceTypeCalDAV:
                            ob_set_v(s, L"type", @"CalDAV");
                            break;
                        case EKSourceTypeExchange:
                            ob_set_v(s, L"type", @"Exchange");
                            break;
                        case EKSourceTypeSubscribed:
                            ob_set_v(s, L"type", @"Subscription");
                            break;
                        case EKSourceTypeBirthdays:
                            ob_set_v(s, L"type", @"Birthday");
                            break;
                        case EKSourceTypeMobileMe:
                            ob_set_v(s, L"type", @"MobileMe");
                            break;
                    }
                    
                    PA_Variable v = PA_CreateVariable(eVK_Object);
                    PA_SetObjectVariable(&v, s);
                    PA_SetCollectionElement(_sources, PA_GetCollectionLength(_sources), v);
                    PA_ClearVariable(&v);
                    
                }
                
                ob_set_c(status, L"sources", _sources);
            }
        }
    }
    
    PA_ReturnObject(params, status);
}

static void iCal_Set_notification_method(PA_PluginParameters params) {
    
    PA_Unistring *arg1 = PA_GetStringParameter(params, 1);
    
    if(1)
    {
        std::lock_guard<std::mutex> lock(globalMutex2);
        
        if(arg1->fLength) {
            iCalv4::LISTENER_METHOD = arg1->fString;
        }else{
            iCalv4::LISTENER_METHOD = (PA_Unichar *)"\0\0";
        }
        
    }
}

static void iCal_Get_notification_method(PA_PluginParameters params) {
    
    PA_ReturnString(params, (PA_Unichar *)iCalv4::LISTENER_METHOD.c_str());
    
}

static void generateUuid(CUTF16String &uuid) {
    
    NSString *u = [[[NSUUID UUID]UUIDString]stringByReplacingOccurrencesOfString:@"-" withString:@""];
    uint32_t len = (uint32_t)[u length];
    uint32_t size = (len * sizeof(PA_Unichar)) + sizeof(PA_Unichar);
    std::vector<uint8_t> buf(size);
    
    if([u getCString:(char *)&buf[0] maxLength:size encoding:NSUnicodeStringEncoding]){
        uuid = CUTF16String((const PA_Unichar *)&buf[0], len);
    }else{
        uuid = (PA_Unichar *)"\0\0";
    }
    
}

void listenerLoop()
{
    if(1)
    {
        std::lock_guard<std::mutex> lock(globalMutex3);
        
        iCalv4::PROCESS_SHOULD_TERMINATE = false;
    }
    
    /* Current process returns 0 for PA_NewProcess */
    PA_long32 currentProcessNumber = PA_GetCurrentProcessNumber();
    
    while(!PA_IsProcessDying())
    {
        PA_YieldAbsolute();
        
        bool PROCESS_SHOULD_RESUME;
        bool PROCESS_SHOULD_TERMINATE;
        
        if(1)
        {
            PROCESS_SHOULD_RESUME = iCalv4::PROCESS_SHOULD_RESUME;
            PROCESS_SHOULD_TERMINATE = iCalv4::PROCESS_SHOULD_TERMINATE;
        }
        
        if(PROCESS_SHOULD_RESUME)
        {
            size_t notifications;
            
            if(1)
            {
                std::lock_guard<std::mutex> lock(globalMutex);
                
                notifications = iCalv4::notifications.size();
            }
            
            while(notifications)
            {
                PA_YieldAbsolute();
                
                if(CALLBACK_IN_NEW_PROCESS)
                {
                    CUTF16String processName;
                    generateUuid(processName);
                    PA_NewProcess((void *)listenerLoopExecuteMethod,
                                  iCalv4::MONITOR_PROCESS_STACK_SIZE,
                                  (PA_Unichar *)processName.c_str());
                }else
                {
                    listenerLoopExecuteMethod();
                }
                
                if(PROCESS_SHOULD_TERMINATE)
                    break;
                
                if(1)
                {
                    std::lock_guard<std::mutex> lock(globalMutex);
                    
                    notifications = iCalv4::notifications.size();
                    PROCESS_SHOULD_TERMINATE = iCalv4::PROCESS_SHOULD_TERMINATE;
                }
            }
            
            if(1)
            {
                std::lock_guard<std::mutex> lock(globalMutex4);
                
                iCalv4::PROCESS_SHOULD_RESUME = false;
            }
            
        }else
        {
            PA_PutProcessToSleep(currentProcessNumber, CALLBACK_SLEEP_TIME);
        }
        
        if(1)
        {
            PROCESS_SHOULD_TERMINATE = iCalv4::PROCESS_SHOULD_TERMINATE;
        }
        
        if(PROCESS_SHOULD_TERMINATE)
            break;
    }
    
    if(1)
    {
        std::lock_guard<std::mutex> lock(globalMutex);
        
        iCalv4::notifications.clear();
    }
    
    if(1)
    {
        std::lock_guard<std::mutex> lock(globalMutex2);
        
        iCalv4::LISTENER_METHOD = (PA_Unichar *)"\0\0";
    }
    
    if(1)
    {
        std::lock_guard<std::mutex> lock(globalMutex1);
        
        iCalv4::METHOD_PROCESS_ID = 0;
    }
    
    if(responder) {
        PA_RunInMainProcess((PA_RunInMainProcessProcPtr)listener_end, NULL);
    }
    
    PA_KillProcess();
}

void listenerLoopStart()
{
    if(!iCalv4::METHOD_PROCESS_ID)
    {
        std::lock_guard<std::mutex> lock(globalMutex1);
        
        iCalv4::METHOD_PROCESS_ID = PA_NewProcess((void *)listenerLoop,
                                                  iCalv4::MONITOR_PROCESS_STACK_SIZE,
                                                  iCalv4::MONITOR_PROCESS_NAME);
    }
}

void listenerLoopFinish()
{
    if(iCalv4::METHOD_PROCESS_ID)
    {
        if(1)
        {
            std::lock_guard<std::mutex> lock(globalMutex3);
            
            iCalv4::PROCESS_SHOULD_TERMINATE = true;
        }
        
        PA_YieldAbsolute();
        
        if(1)
        {
            std::lock_guard<std::mutex> lock(globalMutex4);
            
            iCalv4::PROCESS_SHOULD_RESUME = true;
        }
    }
}

void listenerLoopExecute()
{
    if(1)
    {
        std::lock_guard<std::mutex> lock(globalMutex3);
        
        iCalv4::PROCESS_SHOULD_TERMINATE = false;
    }
    
    if(1)
    {
        std::lock_guard<std::mutex> lock(globalMutex4);
        
        iCalv4::PROCESS_SHOULD_RESUME = true;
    }
    
}

void listenerLoopExecuteMethod()
{
    CUTF8String notification;
    
    if(1)
    {
        std::lock_guard<std::mutex> lock(globalMutex);
        
        std::vector<CUTF8String>::iterator it;
        
        it = iCalv4::notifications.begin();
        
        notification = *it;
        
        iCalv4::notifications.erase(it);
    }
    
    /*
     C_TEXT t;
     t.setUTF8String(&notification);
     PA_Unistring arg1 = PA_CreateUnistring((PA_Unichar *)t.getUTF16StringPtr());
     */
    
    PA_Variable    params[1];
    params[0] = PA_CreateVariable(eVK_Unistring);
    
    method_id_t methodId = PA_GetMethodID((PA_Unichar *)iCalv4::LISTENER_METHOD.c_str());
    
    if(methodId)
    {
        PA_ExecuteMethodByID(methodId, params, 0);
        
    }else if(iCalv4::LISTENER_METHOD.length() != 0)
    {
        PA_Unistring method = PA_CreateUnistring((PA_Unichar *)iCalv4::LISTENER_METHOD.c_str());
        PA_SetStringVariable(&params[0], &method);
        
        PA_ExecuteCommandByID(1007 /* execute method */, params, 1);
    }
    PA_ClearVariable(&params[0]);
}

#pragma GCC diagnostic pop
